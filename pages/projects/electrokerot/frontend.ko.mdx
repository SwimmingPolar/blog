import { Tree, Folder, File, Screenshot, Video } from '@/components'
import '@code-hike/mdx/dist/index.css'

# Electrokerot 프론트엔드

## 1. 기본 설정

> WSL2 + VSCode + Vim + Typescript + Vite

### 1.1 언어

작업에는 <b>`typescript`</b>를 사용했다. 상태관리는 `redux-toolkit`을 통해 하였는데, <b>`redux`</b>는 `boilerplate`가 많아
싫어하거나 불만을 가지는 사람들이 많지만 `redux-toolkit`을 사용하면 `boilerplate`를 많이 줄일 수 있다.
`recoil`이나 `mobx`를 사용해보지 않아서 비교는 못 하지만 문서를 얼핏 봤을 때, `redux`가 더 복잡하다고
단정지어서 말할 순 없을 거 같다.

### 1.2 CRA

프로젝트 생성에는 `vite`를 사용했는데, 이전에 사용하던 `CRA`에 비하면 `vite`의 속도가 엄청나다.

## 2. 스토리북

스토리북을 처음 적용하는 프로젝트였는데, `storybook`을 사용하다보니 API 서버를 개발할 때 `TDD`를 적용했을 때 느낌을 받았다.
격리 된 환경에서 필요한 컴포넌트를 개발하니 전체 웹사이트를 보고 개발하는 것보다 훨씬 효율적이었다. 서버 개발과 마찬가지로
개발환경과 웹사이트 사이의 컨텍스트 스위칭을 크게 줄일 수 있음으로 개발 집중도가 올라갔다.

<details>
  <summary>스토리북</summary>
  https://63dd20176a04b143f58e1507-doimbrkmbm.chromatic.com
</details>

스토리북을 적용하는 방법은 크게 2가지가 있어보이는데,

- 아토믹 디자인을 적용해 디자인 시스템을 구축
- 모듈러 컴포넌트 단위로 개발

서비스가 플랫폼이거나 에이전시 일 경우, 디자인 시스템을 구축하는 것이 좋을 것 같다.
하지만 개인 프로젝트 같은 경우는 필요한 컴포넌트를 개발하고 스토리를 생성하는 것이 더 효율적일 것 같다.
개발을 하다 필요에 따라 다르게 적용하는 것이 맞겠지만, 크게 봤을 때
이런 기준을 정하고 개발을 진행했다.

**Context Decorator**

스토리를 처음 쓰다보면 어떤 컴포넌트들이 의존하는 컨텍스트들이 있는데 이런 건
`Provider`와 같이 전체 `Context Provider`를 추상화하여 전역으로 `react`의 `app`과 스토리북의 컴포넌트에
주입했다. 스토리북에 컨텍스트를 적용할 때는 `withProvider`와 같은 `Decorator`를 사용했다.

<details>
  <summary>withProvider</summary>
  ```ts withProvider.tsx
  export const withProvider = (Story: Story) => {
    return (
      <Provider>
        <Story />
      </Provider>
    )
  }
  ```
</details>

<details>
  <summary>withProvider</summary>
  ```tsx Provider.tsx
  type ProviderType = {
    children: JSX.Element
  }
  export const Provider = ({ children }: ProviderType) => (
    <Suspense
      fallback={
        <div>
          <h1>Loading...</h1>
        </div>
      }
    >
      <StoreProvider>
        <DeviceProvider>
          <CustomThemeProvider theme={getTheme('light')}>
            <CustomProvider>{children}</CustomProvider>
          </CustomThemeProvider>
        </DeviceProvider>
      </StoreProvider>
    </Suspense>
  )
  ```

</details>

혹은 라우터 컨텍스트가 없어서 라우팅이 되지 않는 경우도 있다.

<details>
  <summary>withRouter</summary>
  ```tsx withRouter.tsx
  type RouterOption = Pick<Parameters<typeof createMemoryRouter>, '1'>[1]
  type WithRouterProps = {
    path: string
    options?: RouterOption
  }
  export const withRouter = ({ path, options }: WithRouterProps) => {
    return function withRouterDecorator(Story: Story) {
      return (
        <MemoryRouter {...options}>
          <Routes>
            {path ? <Route path={path} element={<Story />} /> : null}
            <Route path="*" element={<Story />} />
          </Routes>
        </MemoryRouter>
      )
    }
  }
  ```
</details>

## 3. Cypress

지속가능한 개발을 위해서 테스팅을 적용해야 하지만 현재 프로젝트는 `TDD`가 적용되어 있지 않다.
하지만 부분적으로 `Cypress`를 적용해서 테스트를 진행했다. 복잡한 `UI/UX`를 개발한 뒤,
수정을 하다보면 `UI/UX`가 깨지는 경우가 종종 발생한다. 이런 경우를 방지하기 위해 `Cypress`를 적용했다.

추후, `TDD`를 추가할 예정이다. `TDD`가 없을 경우, 프로젝트의 지속 가능성이 거의 없다고 생각한다.

## 4. 디자인

디자인은 피그마를 통해서 했다. 처음 써봤지만 생각보다 편하게 사용할 수 있었다.
화면은

- mobile
- tablet
- desktopSmall
- desktopLarge

이 정도로 4개를 구성했고, 개발할 때는 `foldable`의 미디어쿼리를 추가해
필요한 곳에서 대응했다.

import FigmaScreenshot from '/public/pages/projects/electrokerot/frontend/figma.png'

<Screenshot
  src={FigmaScreenshot}
  alt="반응형 디자인 화면"
  caption="반응형 디자인 화면"
/>

여러 사이트를 참조했고, 사이트나 앱을 사용하면서 느꼈던 생각이나 경험을 디자인이나 `UI/UX`에 녹여내려고 했다.

## 5. 훅/컨텍스트 API

`react`사용 경험이 많이 없을 땐, 오히려 `redux로 많은 걸 해결할 줄 알았는데 사용해보니 컨텍스트API를 사용하는 것이 훨씬 편하고 그렇게 해야하만 하는 경우가 많았다. 특히, 반응형에 대응할 때 많이 썼던 `useDeviceDetect`라는 훅을 위해 컨텍스트API를 사용했는데
간단하면서도 편리했다.

<details>
  <summary>DeviceDetectProvider.tsx</summary>
  ```tsx DeviceDetectProvider.tsx
  export type DeviceType =
    | 'mobile'
    | 'foldable'
    | 'tablet'
    | 'desktopSmall'
    | 'desktopLarge'
  const DeviceDetectContext = createContext<DeviceType>('desktopLarge')
  
  export const DeviceDetectContextProvider = ({
    children
  }: {
    children: ReactNode
  }) => {
    const [device, setDevice] = useState<DeviceType>(getDevice())
    useEffect(() => {
      const handleResize = () => {
        // get current device type
        const device = getDevice()
        // set new device type
        setDevice(device)
      }
      window.addEventListener('resize', handleResize)
      return () => {
        window.removeEventListener('resize', handleResize)
      }
    }, [])
    return (
      <DeviceDetectContext.Provider value={device}>
        {children}
      </DeviceDetectContext.Provider>
    )
  }
  ```
</details>

<details>
  <summary>useDeviceDetect.tsx</summary>

```tsx useDeviceDetect.tsx
// This hook is used to get the device type and to check if the device is mobile, foldable, tablet, desktopSmall or desktopLarge
export const useDeviceDetect = () => {
  const device = useContext(DeviceDetectContext)

  return {
    device: useContext<DeviceType>(DeviceDetectContext),
    isMobile: useMemo(() => device === 'mobile', [device]),
    isFoldable: useMemo(() => device === 'foldable', [device]),
    isTablet: useMemo(() => device === 'tablet', [device]),
    isDesktopSmall: useMemo(() => device === 'desktopSmall', [device]),
    isDesktopLarge: useMemo(() => device === 'desktopLarge', [device]),
    isMobileFriendly: useMemo(
      () => ['mobile', 'foldable'].includes(device || ''),
      [device]
    ),
    isDesktopFriendly: useMemo(
      () => ['tablet', 'desktopSmall', 'desktopLarge'].includes(device || ''),
      [device]
    ),
    isDesktop: useMemo(
      () => ['desktopSmall', 'desktopLarge'].includes(device || ''),
      [device]
    )
  }
}
```

</details>

## 6. 배포

현재 개발이 진행 중이기 때문에, 배포는 하지 않았다.
개발이 어느 정도 진행이 되고 난 뒤에,
`vercel`을 통해 `CI/CD`를 따로 구성하지 않아도 되고, `vercel`에서 제공하는
`web vital`과 `analytics`를 사용할 수 있기 때문에 `vercel`을 사용하려고 한다.
